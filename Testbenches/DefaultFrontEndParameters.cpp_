/*
 * DefaultFrontEndParameters.cpp
 *
 *  Created on: 23/05/2019
 *      Author: new-mauro
 */

#include "TopLevel.h"
#include <boost/timer/timer.hpp>

//Global variables which are used by the SignalHandler class
SpectranInterface * SignalHandler::specInterfPtr;
SpectranConfigurator * SignalHandler::specConfiguratorPtr;
SweepBuilder * SignalHandler::sweepBuilderPtr;
CurveAdjuster * SignalHandler::adjusterPtr;
FrontEndCalibrator * SignalHandler::calibratorPtr;
DataLogger * SignalHandler::dataLoggerPtr;
AntennaPositioner * SignalHandler::antPositionerPtr;
RFPloter * SignalHandler::sweepPloterPtr;
RFPloter * SignalHandler::gainPloterPtr;
RFPloter * SignalHandler::nfPloterPtr;

int main()
{
#ifdef RASPBERRY_PI
	wiringPiSetup();
#endif
	boost::timer::cpu_timer timer;
	timer.stop();

	cout << "\n\tPrograma que permite construir las curvas de los parametros del front end que seran utilizadas por defecto" << endl;

	//Instantiation of objects
	SpectranInterface specInterface;
	SpectranConfigurator specConfigurator(specInterface);
	SweepBuilder sweepBuilder(specInterface);
	CurveAdjuster adjuster;
	FrontEndCalibrator calibrator(adjuster);
	RFPloter rfPloter, gainPloter, nfPloter, meanGainPloter, meanNFPloter;
	bool flagOnce=false;
	FreqValues gain[3], meanGain;
	FreqValues noiseFigure[3], meanNoiseFig;

	//Setting of pointers to objects which are used by SignalHandler class
	SignalHandler sigHandler;
	sigHandler.SetupSignalHandler(&specInterface, &specConfigurator, &sweepBuilder, &adjuster, &calibrator);

	cout << "\nIniciando la comunicacion con el dispositivo Spectran HF-60105 V4 X" << endl;
	specInterface.Initialize();
	cout << "La sesion fue iniciada con exito" << endl;

	//Cargando los parametros
	cout << "\nCargando los parametros de configuracion del dispositivo Spectran desde los archivos correspondientes" << endl;
	if( specConfigurator.LoadFixedParameters() )
	{
		//If the fixed parameters were loaded for the first time or they were reloaded, the initial configuration will be repeated
		cout << "\nLos parametros fijos fueron cargados por primera vez o fueron recargados por lo que se efectuara la configuracion inicial" << endl;
		specConfigurator.InitialConfiguration();
		cout << "La configuracion inicial fue realizada con exito" << endl;
	}

	cout << "\nCargando los parametros de las bandas frecuenciales" << endl;
	specConfigurator.LoadBandsParameters();
	cout << "Los parametros de las bandas fueron cargados exitosamente" << endl;

	cout << "Apague el generador de ruido, conmute el switch para que el mismo se conecte a la entrada y presione una tecla para continuar..." << endl;
	WaitForKey();

	for(auto i=0; i<3; i++)
	{
		Sweep uncalSweep;

		cout << "\nIniciando el proceso de calibracion del front end N " << (i+1) << endl;
		calibrator.StartCalibration();

		//Capturando los barridos de cada una de las bandas que componen el barrido completo
		timer.start();
		for(unsigned int i=0; i < specConfigurator.GetNumOfBands(); i++)
		{
			BandParameters currBandParam;
			Sweep currFreqBand;

			cout << "\nSe inicia el proceso de captura de un nuevo barrido, correspondiente a la banda frecuencial N° " << i+1 << endl;
			cout << "Configurando el dispositivo Spectran con los parametros de la siguiente banda frecuencial" << endl;
			currBandParam = specConfigurator.ConfigureNextBand();
			cout << "Fstart=" << (currBandParam.startFreq/1e6) << " MHz, Fstop=" << (currBandParam.stopFreq/1e6) << " MHz, ";
			cout << "RBW=" << (currBandParam.rbw/1e3) << " KHz, Sweep time=" << currBandParam.sweepTime << " ms" << endl;

			currFreqBand = sweepBuilder.CaptureSweep(currBandParam);

			if( uncalSweep.PushBack(currFreqBand) )
				currBandParam.samplePoints--;

			specConfigurator.SetCurrBandParameters(currBandParam);
		}
		cout << "\nFinalizo la captura de un barrido con NS apagado. Sera cargado en el calibrador del front end." << endl;
		calibrator.SetSweep( uncalSweep );

		timer.stop();
		cout << "\nEl tiempo consumido por la captura del ultimo barrido fue:" << endl;
		cout << timer.format(1) << endl;

		if(!flagOnce)
			rfPloter.Plot(uncalSweep, "lines", "Sweep NS off");

		if(!flagOnce)
		{
			cout << "Cargando los parametros de las bandas (ya con valores correctos de numero de muestras) en el FrontEndCalibrator y CurveAdjuster" << endl;
			auto bandsParameters = specConfigurator.GetBandsParameters();
			adjuster.SetBandsParameters(bandsParameters);
			adjuster.SetRefSweep(uncalSweep);
			calibrator.SetBandsParameters(bandsParameters);
			cout << "Cargando los valores del parametero ENR del generador de ruido" << endl;
			calibrator.LoadENR();
		}

		calibrator.TurnOnNS();
		cout << "\nAlimente el generador de ruido y presione una tecla para continuar..." << endl;
		WaitForKey();

		uncalSweep.Clear();

		//Capturando los barridos de cada una de las bandas que componen el barrido completo
		timer.start();
		for(unsigned int i=0; i < specConfigurator.GetNumOfBands(); i++)
		{
			BandParameters currBandParam;
			FreqValues currFreqBand;

			cout << "\nSe inicia el proceso de captura de un nuevo barrido, correspondiente a la banda frecuencial N° " << i+1 << endl;
			cout << "Configurando el dispositivo Spectran con los parametros de la siguiente banda frecuencial" << endl;
			currBandParam = specConfigurator.ConfigureNextBand();
			cout << "Fstart=" << (currBandParam.startFreq/1e6) << " MHz, Fstop=" << (currBandParam.stopFreq/1e6) << " MHz, ";
			cout << "RBW=" << (currBandParam.rbw/1e3) << " KHz, Sweep time=" << currBandParam.sweepTime << " ms" << endl;

			currFreqBand = sweepBuilder.CaptureSweep(currBandParam);

			uncalSweep.PushBack(currFreqBand);
		}
		cout << "\nFinalizo la captura de un barrido con NS on. Sera cargado en el calibrador del front end." << endl;
		calibrator.SetSweep( uncalSweep );

		timer.stop();
		cout << "\nEl tiempo consumido por la captura del ultimo barrido fue:" << endl;
		cout << timer.format(1) << endl;

		if(!flagOnce)
			rfPloter.Plot(uncalSweep, "lines", "Sweep NS on");

		calibrator.EndCalibration();
		cout << "\nApague el generador de ruido y presione una tecla para continuar..." << endl;
		WaitForKey();

		calibrator.EstimateParameters();

		gain[i]=calibrator.GetGain();
		noiseFigure[i]=calibrator.GetNoiseFigure();

		if(!flagOnce)
		{
			gainPloter.Plot(gain[0], "lines", "One estimated gain curve");
			nfPloter.Plot(noiseFigure[0], "lines", "One estimated noise figure curve");
			Sweep sweepNSoff = calibrator.GetSweepNSoff();
			Sweep calSweepNSoff = calibrator.CalibrateSweep(sweepNSoff);
			rfPloter.Plot(calSweepNSoff, "lines", "Calibrated sweep NS off");
			flagOnce=true;
		}
	}

	meanGain = ( gain[0]+gain[1]+gain[2] ) / 3;
	meanNoiseFig = ( noiseFigure[0]+noiseFigure[1]+noiseFigure[2] ) / 3;

	calibrator.SetGain(meanGain);
	calibrator.SetNoiseFigure(meanNoiseFig);

	TimeData timeData;
	timeData.year=2019; timeData.month=5; timeData.day=23;
	timeData.hour=12; timeData.minute=10; timeData.second=5;
	calibrator.SaveFrontEndParam(timeData);

	meanGainPloter.Plot(calibrator.GetGain(), "lines", "Ganancia total del front end");
	meanNFPloter.Plot(calibrator.GetNoiseFigure(), "lines", "Figura de ruido total del front end");

	cout << "\nConmute el switch para capturar el ruido termico de una carga de 50ohm y presione una tecla para continuar..." << endl;
	WaitForKey();

	Sweep uncalSweep;

	timer.start();
	//Capturando los barridos de cada una de las bandas que componen el barrido completo
	for(unsigned int i=0; i < specConfigurator.GetNumOfBands(); i++)
	{
		BandParameters currBandParam;
		FreqValues currFreqBand;

		cout << "\nSe inicia el proceso de captura de un nuevo barrido, correspondiente a la banda frecuencial N° " << i+1 << endl;
		cout << "Configurando el dispositivo Spectran con los parametros de la siguiente banda frecuencial" << endl;
		currBandParam = specConfigurator.ConfigureNextBand();

		currFreqBand = sweepBuilder.CaptureSweep(currBandParam);

		uncalSweep.PushBack(currFreqBand);
	}
	timer.stop();
	cout << "\nEl tiempo consumido por la captura del ultimo barrido fue:" << endl;
	cout << timer.format(1) << endl;

	Sweep calSweep = calibrator.CalibrateSweep(uncalSweep);

	cout << "\nPresione una tecla para terminar..." << endl;
	WaitForKey();

	return 0;
}
