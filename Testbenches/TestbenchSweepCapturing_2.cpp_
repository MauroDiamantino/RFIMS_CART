/*
 * main.cpp
 *
 *  Created on: 28/04/2019
 *      Author: new-mauro
 */

#include "TopLevel.h"

/////////////////////////Global variables///////////////////////
//! Global variables which are used by the SignalHandler class
SpectranInterface * SignalHandler::specInterfPtr;
SpectranConfigurator * SignalHandler::specConfiguratorPtr;
SweepBuilder * SignalHandler::sweepBuilderPtr;
CurveAdjuster * SignalHandler::adjusterPtr;
FrontEndCalibrator * SignalHandler::calibratorPtr;
RFIDetector * SignalHandler::rfiDetectorPtr;
DataLogger * SignalHandler::dataLoggerPtr;
GPSInterface * SignalHandler::gpsInterfacePtr;
AntennaPositioner * SignalHandler::antPositionerPtr;
RFPloter * SignalHandler::sweepPloterPtr;
RFPloter * SignalHandler::gainPloterPtr;
RFPloter * SignalHandler::nfPloterPtr;
//! Flags which are defined by the software arguments and which indicates the way the software must behave
bool flagCalEnabled=true, flagPlot=false, flagInfiniteLoop=true, flagRFI=false;
//! A variable which saves the number of measurements cycles which left to be done. It is used when the user wishes a finite number of measurements cycles.
unsigned int numOfMeasCycles=0;
//! A variable which saves the norm which defines the harmful RF interference levels: ska-mode1, ska-mode2, itu-ra769
RFI::ThresholdsNorm rfiNorm = RFI::SKA_MODE1;
//! A timer which is used to measure the execution time when the number of iterations is finite.
boost::timer::cpu_timer timer;

///////////////////////////////MAIN FUNCTION///////////////////////////////
//! Main function.
int main(int argc, char * argv[])
{
	cout << "\n\t\t\t\tTestbench Sweep Capturing 2" << endl;

	timer.start();

	try
	{
		//////////////////////////////////////INITIALIZATIONS//////////////////////////////////////////
		SpectranInterface specInterface;
		SpectranConfigurator specConfigurator(specInterface);
		SweepBuilder sweepBuilder(specInterface);
		CurveAdjuster curveAdjuster;
		FrontEndCalibrator frontEndCalibrator(curveAdjuster);
		RFIDetector rfiDetector(curveAdjuster);
		RFPloter sweepPloter;

		//Setting of pointers to objects which are used by SignalHandler class
		SignalHandler sigHandler;
		sigHandler.SetupSignalHandler(&specInterface, &specConfigurator, &sweepBuilder, &curveAdjuster,
				&frontEndCalibrator, &rfiDetector);

		//Initializing the spectrum analyzer
		cout << "\nInitializing the spectrum analyzer Aaronia Spectran HF-60105 V4 X..." << endl;
		specInterface.Initialize();
		cout << "The spectrum analyzer was initialized successfully" << endl;
		//////////////////////////////////END OF THE INITIALIZATION///////////////////////////////////////


		////////////////////////LOADING OF THE SPECTRAN'S PARAMETERS//////////////////////////
		//Loading by first time or reloading the Spectran parameters
		cout << "\nLoading the Spectran's configuration parameters from the corresponding files" << endl;
		//Loading the fixed parameters
		cout << "Loading the fixed parameters..." << endl;
		if( specConfigurator.LoadFixedParameters() )
		{
			//If the fixed parameters were loaded for the first time or they were reloaded, the initial configuration will be repeated
			cout << "The fixed parameters were loaded by first time or they were reloaded so the Spectran initial configuration will be done" << endl;
			specConfigurator.InitialConfiguration();
			cout << "The initial configuration was carried out successfully" << endl;
		}

		//Loading the frequency bands parameters
		cout << "Loading the frequency bands' parameters..." << endl;
		specConfigurator.LoadBandsParameters();
		cout << "The frequency bands' parameters were loaded successfully" << endl;
		//////////////////////END OF THE LOADING OF THE SPECTRAN'S PARAMETERS////////////////


		///////////////////////////////////CAPTURE LOOP OF A WHOLE SWEEP////////////////////////////////////
		Sweep uncalSweep;
		cout << "\nStarting the capturing of a whole sweep" << endl;
#ifdef RASPBERRY_PI
		digitalWrite(piPins.LED_SWEEP_CAPTURE, HIGH);
#endif
		//Capturing the sweeps related to each one of the frequency bands, which in conjunction form a whole sweep
		for(unsigned int i=0; i < specConfigurator.GetNumOfBands(); i++)
		{
			BandParameters currBandParam;
			FreqValues currFreqBand;

			currBandParam = specConfigurator.ConfigureNextBand();
			cout << "\nFrequency band NÂ° " << i+1 << endl;
			cout << "Fstart=" << (currBandParam.startFreq/1e6) << " MHz, Fstop=" << (currBandParam.stopFreq/1e6) << " MHz, ";
			cout << "RBW=" << (currBandParam.rbw/1e3) << " KHz, Sweep time=" << currBandParam.sweepTime << " ms" << endl;

			currFreqBand = sweepBuilder.CaptureSweep(currBandParam);

			bool flagLastPointRemoved = uncalSweep.PushBack(currFreqBand);
			if( flagLastPointRemoved )
				currBandParam.samplePoints--;
			
			specConfigurator.SetCurrBandParameters(currBandParam);
		}

#ifdef RASPBERRY_PI
		digitalWrite(piPins.LED_SWEEP_CAPTURE, LOW);
#endif
		specInterface.SoundNewSweep();
		cout << "\nThe capturing of a whole sweep finished" << endl;
		////////////////////////////END OF THE CAPTURE LOOP OF A WHOLE SWEEP////////////////////////////////


		/////////////////////////////////SWEEP PROCESSING/////////////////////////////////////
		try
		{
			//Ploting the current sweep
			cout << "\nThe captured sweep will be plotted" << endl;
			sweepPloter.Clear();
			sweepPloter.PlotSweep(uncalSweep);
		}
		catch(std::exception & exc)
		{
			cerr << "\nWarning: " << exc.what();
		}
		////////////////////////////////END OF SWEEP PROCESSING///////////////////////////////////

		cout << "\nThe sweep capturing process finished." << endl;

//		cout << "\nThe latency time is: " << (int)specInterface.GetLatencyTime() << " ms" << endl;
//		cout << "The USB IN Transfer size is: " << specInterface.GetUSBInTransferSize() << " bytes" << endl;

		if( !timer.is_stopped() )
		{
			//Showing the elapsed time since the beginning
			timer.stop();
			boost::timer::cpu_times times = timer.elapsed();
			//double hours = double(times.wall)/(1e9*3600.0);
			//cout << "\nThe elapsed time since the beginning is: " << hours << " hours" << endl;
			boost::posix_time::time_duration td = boost::posix_time::microseconds(times.wall/1000);
			cout << "\nThe elapsed time since the beginning is: " << boost::posix_time::to_simple_string(td) << endl;
		}

		cout << "\nPresione enter para terminar..." << endl;
		WaitForKey();
	}
	catch(CustomException & exc)
	{
		cerr << "\nError: " << exc.what() << endl;
		
		if( !timer.is_stopped() )
		{
			//Showing the elapsed time since the beginning
			timer.stop();
			boost::timer::cpu_times times = timer.elapsed();
			//double hours = double(times.wall)/(1e9*3600.0);
			//cout << "\nThe elapsed time since the beginning is: " << hours << " hours" << endl;
			boost::posix_time::time_duration td = boost::posix_time::microseconds(times.wall/1000);
			cout << "\nThe elapsed time since the beginning is: " << boost::posix_time::to_simple_string(td) << endl;
		}
		
		std::exit(EXIT_FAILURE);
	}

	return 0;
}
////////////////////////////END OF MAIN FUNCTION/////////////////////////////////
