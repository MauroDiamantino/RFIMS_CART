/*!	\file SweepProcessing.h
 * 	\brief This header file contains the declarations of the classes which are responsible
 * 	for the processing of each sweep, once it has been captured.
 *
 * 	The tasks which are performed by the classes defined here are the following:
 * 	- Plotting of sweeps, RFI and any frequency curve.
 * 	- Adjusting (interpolation) of frequency curves.
 * 	- Front end calibration.
 * 	- RFI detection.
 * 	- Data logging.
 * 	\author Mauro Diamantino
 */

#ifndef SWEEPPROCESSING_H_
#define SWEEPPROCESSING_H_

// Inclusion of the header file which has the declarations of the global functions, global classes, etc. and the inclusions of the global libraries.
#include "Basics.h"

#include "gnuplot_i.hpp" //A C++ interface to gnuplot
#include <queue> //This library allows the use the `std::queue` container


//! The class _RFPlotter_ is intended to plot sweeps, RF interference (RFI) and any frequency curve.
/*! This function uses \em Gnuplot which is a C++ interface to the software \em gnuplot,
 * 	a portable command-line driven graphing utility for Linux and other platforms. The interface
 * 	uses a pipe to communicate with the software. Each instantiation of this class represents a
 * 	different plot.
 */
class RFPlotter
{
	//Class' attributes//
	Gnuplot plotter; //!< An object which represent an interface to the software \em gnuplot.
	std::string title; //!< The title of the plot.
	Sweep sweep; //!< The last sweep which was plotted
	//Private methods//
	//! This method makes an initial configuration of each plot.
	void ConfigureGraph()
	{
		plotter.unset_grid(); plotter.set_legend("inside"); plotter.set_legend("right"); plotter.set_legend("top");
		plotter.set_legend("nobox"); plotter.set_title(title); plotter.set_xlabel("Frequency (Hz)");
	}
public:
	//Class interface//
	//! The unique _RFPloter_ constructor.
	/*! The constructor can receive a title for the plot but by default this is empty.
	 * 	This method set the style of the plot to "lines" and it performs an initial
	 * 	configuration of this one.
	 */
	RFPlotter(const std::string & titl="") : plotter("lines"), title(titl) {	ConfigureGraph();	}
	//! The class destructor.
	/*!	The destructor removes the temporary files which are generated by the \em Gnuplot interface.	*/
	~RFPlotter() {	plotter.remove_tmpfiles();	}
	//! This method is intended to plot any kind of frequency curve.
	/*!	\param [in] curve The frequency curve to be plotted.
	 * 	\param [in] style The style of the plot: "lines", "points", "linespoints", "impulses", "dots",
	 * 	"steps", "fsteps", "histeps", "boxes", "filledcurves" or "histograms".
	 * 	\param [in] name The name or title of the plot.
	 */
	void Plot(const FreqValues & curve, const std::string & style = "lines", const std::string & name = "")
	{
		plotter.set_style(style); plotter.set_title(name);
		if( curve.type=="gain" || curve.type=="noise figure" || curve.type=="noise temperature")
		{
			std::vector<double> freqMHz;
			for(const auto f : curve.frequencies)
				freqMHz.push_back( double(f)/1e6 );

			if(curve.type=="gain")
				plotter.set_ylabel("Gain (dB)");
			else if(curve.type=="noise figure")
				plotter.set_ylabel("Noise Figure (dB)");
			else if (curve.type=="noise temperature")
				plotter.set_ylabel("Noise Temperature (°K)");

			plotter.set_xlabel("Frequency (MHz)");
			plotter.plot_xy(freqMHz,curve.values,name);
		}
		else
			plotter.plot_xy(curve.frequencies,curve.values,name);
	}
	//! This method is specially intended to plot sweeps.
	/*!	This method receives a _Sweep_ object, plots it, gives a special title
	 * 	to the plot, which contains the info of the sweep, it sets the style
	 * 	to "lines" and it sets the x axis label in "Frequency (MHz)" and the y
	 * 	axis label in "Power (dBm)". So, the frequencies are represented in MHz
	 * 	and the values of the sweep are assumed to be power values in dBm. The
	 * 	curve label is set to "Calibrated sweep" because it is assumed that the
	 * 	plotting is performed after the calibration.
	 * 	\param [in] swp The sweep to be plotted.
	 */
	void PlotSweep(const Sweep& swp)
	{
		sweep=swp;
		std::ostringstream oss;
		oss << "Calibrated sweep, Azimuth: " << sweep.azimuthAngle;
		oss << " degrees N, Polarization: " << sweep.polarization << ", " << sweep.timeData.GetTimestamp();
		plotter.set_title( oss.str() ); plotter.set_xlabel("Frequency (MHz)");
		plotter.set_ylabel("Power (dBm)"); plotter.set_style("lines");
		std::vector<double> freqMHz;
		for(const auto f : sweep.frequencies)
			freqMHz.push_back( double(f)/1e6 );
		plotter.plot_xy(freqMHz, sweep.values, "Calibrated sweep");
	}
	//! This method is specially intended to plot RF interference (RFI).
	/*!	This method is designed to plot the RFI which was detected in a determined sweep,
	 * after that sweep has already been plotted. Because of that, the plot's title and
	 * axes labels are not changed, but the style is changed to "points" to make a
	 * difference between the sweep points and the RFI points, which will be superimposed
	 * where there is RFI. Also, it is controlled the given _RFI_ object has the same azimuth
	 * angle and polarization of the plotted sweep. Again, the frequencies are represented
	 * in MHz and the RFI values are assumed to be power values in dBm.
	 * \param [in] rfi The RFI to be plotted.
	 */
	void PlotRFI(const RFI & rfi)
	{
		if( !rfi.Empty() )
		{
			if( rfi.azimuthAngle==sweep.azimuthAngle && rfi.polarization==sweep.polarization )
			{
				plotter.set_style("points");
				std::vector<double> freqMHz;
				for(const auto f : rfi.frequencies)
					freqMHz.push_back( double(f)/1e6 );
				plotter.plot_xy(freqMHz, rfi.values, "Detected RFI");
			}
			else
				throw rfims_exception("The RFI which was given to be plotted is not related to the plotted sweep.");
		}
	}
	//! This method cleans completely the plot, but the corresponding window will not be closed.
	void Clear() {	plotter.reset_all(); ConfigureGraph(); sweep.Clear();	}
};

//! The aim of the class _CurveAdjuster_ is to adjust any frequency curve, this is to interpolate and/or extrapolate the curve of a given parameter versus frequency.
class CurveAdjuster
{
	//Class data types//
	struct LinearFunction
	{
		float slope;
		float y_intercept;
		std::uint_least64_t f_min, f_max;
		float Evaluate(const std::uint_least64_t freqValue)
		{
			if( f_min<=freqValue && freqValue<=f_max )
				return( slope*freqValue + y_intercept );
			else
				throw( rfims_exception("Out-of-range calculation on a linear function.") );
		}
	}; //!< This structure is intended to store the data of a linear function, in the frequency domain.
	//Attributes//
	std::vector<BandParameters> bandsParameters; //!< A vector with the parameters of all frequency bands.
	Sweep refSweep; //!< A sweep which is used as reference to determine the exact frequency values which are captured.
	std::vector<LinearFunction> lines; //!< A vector with the set of linear functions which are got when a curve is linearly interpolated.
	FreqValues adjCurve; //!< The adjusted (interpolated and extrapolated) curve.
	//Private methods//
	//! This method gets the set of linear functions which interpolate and extrapolate the given curve.
	void BuildLines(const FreqValues& curve);
public:
	//Class interface//
	//! The unique constructor of the class.
	CurveAdjuster() : adjCurve("") {}
	//! The destructor of the class.
	/*!	Its implementation is empty because the attributes destruction is implicitly. However, the
	 * destructor is defined here to allow this one to be called explicitly in any part of the code,
	 * what is used by the signals handler to destroy the objects when a signal to finish the execution
	 * of the software is received.
	 */
	~CurveAdjuster() {}
	//! This method allows to give the bands' parameters to the object.
	/*!	The bands' parameters are taken into account to perform the adjusting
	 * 	of a curve.
	 * 	\param [in] bandsParam The frequency bands' parameters.
	 */
	void SetBandsParameters(const std::vector<BandParameters> & bandsParam) {	bandsParameters=bandsParam;	}
	//! This method allow to give the reference sweep to the object.
	/*!	The reference sweep is used to know which are the exact frequency values
	 * which are delivered by the spectrum analyzer. This allows to correctly perform
	 * the curve adjusting.
	 * \param [in] swp The reference sweep.
	 */
	void SetRefSweep(const Sweep & swp) {	refSweep = swp;		}
	//! This is the central method which allows to adjust a frequency curve
	const FreqValues& AdjustCurve(const FreqValues & curve);
	//! This method returns the last adjusted curve.
	const FreqValues& GetAdjustedCurve() const {	return adjCurve;	}
};

//! The aim of this class is to calculate the total gain and total noise figure curves versus frequency of the RF front end.
class FrontEndCalibrator
{
	//Attributes//
	//Constants
	const std::string CAL_FILES_PATH = BASE_PATH + "/calibration"; //!< The path were the related files are saved.
	const float REF_TEMPERATURE = 290.0; //!< The reference temperature in Kelvin, 290 °K.
	const float BOLTZMANN_CONST = 1.3806488e-23; //!< The Boltzmann constant.
	//Variables
	CurveAdjuster & adjuster; //!< A reference to the instantiation of _CurveAdjuster_, which is the unique responsible of the adjusting of curves.
	time_t enrFileLastWriteTime; //!< The last-modification time (in seconds from the Unix epoch) of the file with the ENR values of the noise generator.
	FreqValues correctENR; //!< A structure which stores the corrected ENR values (taking into account Application Note 57-2 of Keysight) versus frequency.
	float tsoff; //!< The noise temperature of the noise generator when it is turned off, which matches the physical temperature.
	FreqValues powerNSoff; //!< A structure which stores the output power values measured when the noise generator is turned off and represented in dBm.
	FreqValues powerNSon; //!< A structure which stores the output power values measured when the noise generator is turned on and represented in dBm.
	FreqValues powerNSoff_w; //!< A structure which stores the output power values measured when the noise generator is turned off and represented in Watts(W).
	FreqValues powerNSon_w; //!< A structure which stores the output power values measured when the noise generator is turned on and represented in Watts(W).
	std::vector<BandParameters> bandsParameters; //!< A vector which stores the parameters of all frequency bands.
	bool flagNSon; //!< A flag which indicates if the noise source is turned on or not.
	FreqValues gain; //!< A structure which stores the estimated gain values of the front end versus the frequency, represented in dB.
	FreqValues noiseTemperature; //!< A structure which stores the estimated equivalent noise temperature values of the front end versus the frequency and represented in °K.
	FreqValues noiseFigure; //!< A structure which stores the estimated noise figure values of the front end versus the frequency and represented in dB.
	bool flagCalStarted; //!< A flag which indicates if the calibration process has been started, turning off the noise source and switching the input to this device.
	Sweep calSweep; //!< A structure which stores the power values of the last calibrated sweep.
	FreqValues rbwCurve; //!< A structure which stores the RBW values versus the frequency, taking into account this parameter for each frequency band.
#ifdef DEBUG
	RFPlotter auxRFPloter; //!< This plotter is intended to see internal steps of the calibration process of a given sweep.
#endif
	//Private methods//
	//! This method builds a curve with RBW values versus frequency, taking into account this parameter for each frequency band.
	void BuildRBWCurve();
public:
	//Class Interface//
	//! The default class constructor.
	FrontEndCalibrator(CurveAdjuster & adj);
	//! A more complete constructor which allows to insert the vector with the parameters of all frequency bands.
	FrontEndCalibrator(CurveAdjuster & adj, const std::vector<BandParameters> & bandsParam);
	//! The _FrontEndCalibrator_ destructor.
	/*!	Its implementation is empty because the attributes destruction is implicitly. However, the
	 * destructor is defined here to allow this one to be called explicitly in any part of the code,
	 * what is used by the signals handler to destroy the objects when a signal to finish the execution
	 * of the software is received.
	 */
	~FrontEndCalibrator() {}
	//! This method allows to insert a vector with the parameters of all frequency bands.
	void SetBandsParameters(const std::vector<BandParameters> & bandsParam);
	//! This method load the curve of ENR values versus frequency of the noise generator, from the corresponding file.
	void LoadENR();
	//! The calibration is started ensuring the noise source is turned off, switching the input to this device and preparing the object to receive the sweeps.
	void StartCalibration();
	//! This method just turns on the noise generator and it internally registers this situation.
	void TurnOnNS();
	//! This method just turns off the noise generator and it internally registers this situation.
	void TurnOffNS()
	{
	#ifdef RASPBERRY_PI
			digitalWrite(piPins.NOISE_SOURCE, LOW); flagNSon = false;
	#endif
	}
	//! The calibration process is finished turning it off the noise generator and switching the input to the antenna.
	void EndCalibration();
	//! This method is intended to insert the two sweeps which are captured during the calibration process, with the noise source turned on and off.
	void SetSweep(const FreqValues & sweep);
	//! This method allow to set the equivalent noise temperature of the noise source when it is turned off, what matches its physical temperature.
	void SetNSoffTemp(const float nsOffTemp) {	tsoff = nsOffTemp;	}
	//! This is one of the central methods. It estimates the front end parameters once the two sweeps were captured.
	void EstimateParameters();
	//! This method returns the estimated total gain curve of the front end.
	const FreqValues & GetGain() const {	return gain;	}
	//! This method returns the estimated total noise temperature curve of the front end.
	const FreqValues & GetNoiseTemp() const {	return noiseTemperature;	}
	//! This method returns the estimated total noise figure curve of the front end.
	const FreqValues & GetNoiseFigure() const {		return noiseFigure;		}
	//! This method returns the corrected ENR values of the noise source.
	FreqValues GetENRcorr() const {	return correctENR;		}
	//! This method returns the noise temperature of the noise source when it is turned off, what matches its physical temperature.
	float GetNSoffTemp() const {	return tsoff;	}
	//! This method returns the sweep with output power values which were got with the noise source turned off.
	const FreqValues & GetSweepNSoff() const {	return powerNSoff;	}
	//! This method returns the sweep with output power values which were got with the noise source turned on.
	const FreqValues & GetSweepNSon() const {	return powerNSon;	}
	//! This method allows to know if the calibration has been started, i.e. the noise source is connected to the input.
	bool IsCalibStarted() const {	return flagCalStarted;		}
	//! This method allows to know if the noise source is turned off or not.
	bool IsNoiseSourceOff() const {	return !flagNSon;	}
	//! This another central method which is intended to calibrate (correct) the sweeps obtained with the antenna, once the front end parameters have been estimated.
	const Sweep& CalibrateSweep(const Sweep & uncalSweep);
	//! This method returns the last calibrated sweep.
	const Sweep& GetCalSweep() const {	return calSweep;	}
	//! When errors occur during the calibration process, a set of default parameters curves are used to calibrate sweeps. This method loads those curve from the corresponding files.
	void LoadDefaultParameters();
	//! This method returns a `true` if no front end parameters have been estimated or loaded from the corresponding files, and a `false` otherwise.
	bool AreParamEmpty() {	return( gain.Empty() || noiseTemperature.Empty() || noiseFigure.Empty() );	}
#ifdef DEBUG
	void SetGain(const FreqValues & g) {	gain=g;		}
	void SetNoiseTemp(const FreqValues & nt) {	noiseTemperature=nt;	}
	void SetNoiseFigure(const FreqValues & nf) {	noiseFigure=nf;		}
#endif
};


//! The aim of this class is to compare each calibrated sweep with a threshold curve to determine where there is RF interference (RFI).
class RFIDetector
{
	//Class' attributes//
	//Constants
	const std::string THRESHOLDS_PATH = BASE_PATH + "/thresholds"; //!< The path were there are the files wit the thresholds curve.
	const double ANTENNA_GAIN = 5.0; //!< The gain of the Aaronia HyperLOG 60100 antenna, measured in dBi.
	const double SPEED_OF_LIGHT = 2.99792e8; //!< The speed of light in vacuum, measured in m/s.
	//Variables
	CurveAdjuster & adjuster; //!< A reference to the _CurveAdjuster_ object, which is used here to adjust some internal curves.
	std::vector<BandParameters> bandsParameters; //!< A vector with the parameters of all frequency bands.
	RFI rfi; //!< A structure which stores the last detected RFI.
	FreqValues thresholdsCurve; //!< A structure which stores the thresholds curve.
	time_t threshFileLastWriteTime; //!< The last-modification time (seconds from the Unix epoch) of the file with the threshold curve.
public:
	//Class interface//
	//! The unique class constructor.
	/*!	At instantiation the programmer must provide a reference to a _CurveAdjuster_ object.
	 * \param [in] adj A _CurveAdjuster_ object.
	 */
	RFIDetector(CurveAdjuster & adj) : adjuster(adj), thresholdsCurve("threshold curve") { threshFileLastWriteTime=0; }
	//! The class destructor.
	/*!	Its implementation is empty because the attributes destruction is implicitly. However, the
	 * destructor is defined here to allow this one to be called explicitly in any part of the code,
	 * what is used by the signals handler to destroy the objects when a signal to finish the execution
	 * of the software is received.
	 */
	~RFIDetector() {}
	//! A method to insert a vector with the parameters of all frequency bands.
	void SetBandsParameters(const std::vector<BandParameters> & bandsParam) {	bandsParameters=bandsParam;	}
	//! This method loads a determined thresholds curve from the corresponding file.
	void LoadThreshCurve(const RFI::ThresholdsNorm thrNorm);
	//! This method detects RFI in a calibrated sweep.
	const RFI & DetectRFI(const Sweep & sweep);
	//! This method returns the threshold curve which has been loaded.
	const FreqValues & GetThreshCurve() const {		return thresholdsCurve;		}
	//! This method returns the number of RFI bands which were detected in the last sweep.
	unsigned int GetNumOfRFIBands() const {		return rfi.numOfRFIBands;	}
	//! This method returns the last detected RFI.
	const RFI & GetRFI() const {	return rfi;		}
};

//! The class _DataLogger_ is intended to handle the storing of the generated data into memory, following the CSV (comma-separated values) format.
class DataLogger
{
	//Attributes//
	//Constants
	const std::string MEASUREMENTS_PATH = BASE_PATH + "/measurements"; //!< The path where the files with measurements must be saved.
	const std::string FRONT_END_PARAM_PATH = BASE_PATH + "/calibration/frontendparam"; //!< The path were the files with the front end parameters must be saved.
	const std::string BANDS_PARAM_CSV_PATH = BASE_PATH + "/parameters/csv"; //!< The path were the file with the parameters of all frequency bands is saved, with CSV format.
	const std::string UPLOADS_PATH = BASE_PATH + "/uploads"; //!< The path were the files to be uploaded must be put.
	const unsigned int NUM_OF_POSITIONS = 6; //!< The number of azimuth positions of the antenna positioning system.
	//Variables
	std::ofstream ofs; //!< This object is used to write the data into the different files, following a specific format.
	unsigned int sweepIndex; //!< An index which allows to know which is the current sweep in the entire measurement cycle, and how many sweeps remain until the end.
	std::string currMeasCycleTimestamp; //!< The timestamp of the current measurement cycle, which is taken as the date at the beginning.
	bool flagNewBandsParam; //!< A flag which indicates if new bands parameters were loaded and inserted to this object to save them in a CSV file, in the current measurement cycle.
	bool flagNewFrontEndParam; //!< A flag which indicates if new front end parameters were estimated and inserted to this object to save them into memory, in the current measurement cycle.
	bool flagStoredRFI; //!< A flag which indicates if the object was asked to store RFI in the current measurement cycle.
	std::queue<std::string> filesToUpload; //!< A structure which contains the names of the files which remain to be uploaded.
	pthread_t uploadThread; //!< A variable which saves the ID of the thread created to upload the data to remote server, in parallel with the capture of a new sweep.
	char threadMsg[100]; //!< An array which saves a message the thread can returned when there was an error.
public:
	//Class interface//
	//! The unique class constructor.
	DataLogger();
	//! The class destructor.
	~DataLogger();
	//! This method is intended to save the bands parameters in a CSV file which is more adequately to be read in the remote server.
	void SaveBandsParamAsCSV(const std::vector<BandParameters> & bandsParamVector);
	//! This method is intended to save the estimated front end parameters, gain and noise figure, into the non-volatile memory.
	void SaveFrontEndParam(const FreqValues & gain, const FreqValues & noiseFigure);
	//! This method is intended to save a calibrated sweep into the non-volatile memory.
	void SaveSweep(const Sweep& sweep);
	//! This method is intended to save the detected RFI in the last sweep, into the non-volatile memory.
	void SaveRFI(const RFI& rfi);
	//! The aim of this method is to delete the old files.
	void DeleteOldFiles() const;
	//! The aim of this method is to prepare, archive and compress, the files which will be send to the remote server.
	void ArchiveAndCompress();
	//! This method is responsible for the uploading of the data files to the remote server.
	void UploadData();
	//! This method creates a thread where the data files will be uploaded, in parallel with the capture of a new sweep.
	void PrepareAndUploadData();
	//Friend functions//
	friend void *UploadThreadFunc(void*);
};

#endif /* SWEEPPROCESSING_H_ */
